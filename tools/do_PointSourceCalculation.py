# -*- coding: utf-8 -*-
"""
/***************************************************************************
 opeNoise

 opeNoise allows to compute the noise level generated by point source or 
 by road source at fixed receiver points and buildings.

                             -------------------
        begin                : March 2014
        copyright            : (C) 2014 by Arpa Piemonte
        email                : s.masera@arpa.piemonte.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt4.QtGui import *
from PyQt4.QtCore import *
from qgis.core import *

import os, imp
import traceback

from math import *
from string import find
from datetime import datetime
from ui_PointSourceCalculation import Ui_PointSourceCalculation_window

from symbols import render

# import VectorWriter
try:
    # Qgis from 2.0 to 2.4
    from processing.core.VectorWriter import VectorWriter
except:
    # Qgis from 2.6
    from processing.tools.vector import VectorWriter


class Dialog(QDialog,Ui_PointSourceCalculation_window):
    
    def __init__(self, iface):
        QDialog.__init__(self, iface.mainWindow())
        self.iface = iface
        # Set up the user interface from Designer.
        self.setupUi(self)
        
        string = "<html><head/><body><p><span style=\" font-style:italic;\">" + self.tr("Optional") + "</span></p></body></html>"
        self.note_label_2.setText(string)
        
       
        self.progressBar.setValue(0)
        
        self.obstacles_check_value = 0
        self.rays_check_value = 0
        
        self.populateLayers()
        self.update_field_source_layer()
        QObject.connect(self.source_layer_comboBox, SIGNAL("currentIndexChanged(QString)"), self.update_field_source_layer)
        
        QObject.connect(self.obstacles_layer_checkBox, SIGNAL("toggled(bool)"), self.obstacles_check)
        
        self.rays_check_value = 0        
        QObject.connect(self.rays_layer_checkBox, SIGNAL("toggled(bool)"), self.rays_check)
        QObject.connect(self.rays_layer_pushButton, SIGNAL("clicked()"), self.outFile_rays)

        
    def populateLayers( self ):
        self.source_layer_comboBox.clear()
        layers_point = []
        for layer in QgsMapLayerRegistry.instance().mapLayers().values():
            try:
                if layer.geometryType() == QGis.Point:
                    layers_point.append(layer.name())
            except:            
                continue

        layers_point.sort()
        self.source_layer_comboBox.addItems(layers_point)
        
        self.receiver_layer_comboBox.clear()
        self.receiver_layer_comboBox.addItems(layers_point)
        
        research_ray = ['50','100','200','500','1000']        
        self.research_ray_comboBox.clear()
        for distance in research_ray:
            self.research_ray_comboBox.addItem(distance)
        
        self.obstacles_layer_comboBox.clear()
        obstacles_layers = []
        for layer in QgsMapLayerRegistry.instance().mapLayers().values():
            try:
                if layer.geometryType() == QGis.Polygon:
                    obstacles_layers.append(layer.name())
            except:            
                continue

        obstacles_layers.sort()
        self.obstacles_layer_comboBox.addItems(obstacles_layers)
        
    
    def update_field_source_layer(self):
        
        if unicode(self.source_layer_comboBox.currentText()) == "":
            return

        source_layer = QgsMapLayerRegistry.instance().mapLayersByName(self.source_layer_comboBox.currentText())[0]
        source_layer_fields = list(source_layer.dataProvider().fields())
        
        #self.id_field_comboBox.clear() 
        self.power_comboBox.clear()        
        
        source_layer_fields_number = [self.tr("choose field")]
        
        for f in source_layer_fields:
            if f.type() == QVariant.Int or f.type() == QVariant.Double:         
                source_layer_fields_number.append(unicode(f.name()))

        for f_label in source_layer_fields_number:
            self.power_comboBox.addItem(f_label)

    def obstacles_check(self):
        
        if self.obstacles_check_value == 0:        
            self.obstacles_layer_comboBox.setEnabled( True ) 
            self.obstacles_check_value = 1
        else:
            self.obstacles_layer_comboBox.setEnabled( False ) 
            self.obstacles_check_value = 0     
            
    def rays_check(self):
        
        if self.rays_check_value == 0:        
            #self.rays_layer_lineEdit.setEnabled( True ) 
            self.rays_layer_pushButton.setEnabled( True ) 
            self.rays_check_value = 1
        else:
            #self.rays_layer_lineEdit.setEnabled( False ) 
            self.rays_layer_pushButton.setEnabled( False ) 
            self.rays_check_value = 0 
            
    def outFile_rays(self):
        
        self.rays_layer_lineEdit.clear()
        self.shapefileName = QFileDialog.getSaveFileName(None,'Open file', "", "Shapefile (*.shp);;All files (*)")
        
        if self.shapefileName is None or self.shapefileName == "":
            return
            
        if find(self.shapefileName,".shp") == -1 and find(self.shapefileName,".SHP") == -1:
            self.rays_layer_lineEdit.setText( self.shapefileName + ".shp")
        else:
            self.rays_layer_lineEdit.setText( self.shapefileName)
       

    def log_start(self):
        
        # creates 2 log file: settings and errors
        global log_errors, log_settings,log_settings_path_name,log_errors_path_name
        path = os.path.abspath(__file__)
        dir_path = os.path.dirname(path)        
        log_settings_path_name = os.path.join(dir_path,"log_PointSourceCalculation_settings.txt")
        log_errors_path_name = os.path.join(dir_path,"log_PointSourceCalculation_errors.txt")
        log_settings = open(log_settings_path_name,"w")
        log_errors = open(log_errors_path_name,"w")
        log_settings.write(self.tr("opeNoise") + " - " + self.tr("Point Source Calculation") + " - " + self.tr("Settings") + "\n\n")
        log_errors.write(self.tr("opeNoise") + " - " + self.tr("Point Source Calculation") + " - " + self.tr("Errors") + "\n\n")
        
        
    def log_end(self):

        log_settings.close()        
        log_errors.close()    

    def accept(self):
        
        self.buttonBox.setEnabled( False )
        
        if self.source_layer_comboBox.currentText() == "":
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("Please specify input point vector layer as source."))
            self.buttonBox.setEnabled( True )
            return
        if self.receiver_layer_comboBox.currentText() == "":
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("Please specify input point vector layer as receiver."))
            self.buttonBox.setEnabled( True )
            return
        if self.power_comboBox.currentText() == self.tr("choose field"):
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("Please choose power field."))
            self.buttonBox.setEnabled( True )
            return
        if self.source_layer_comboBox.currentText() == self.receiver_layer_comboBox.currentText():
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("It is not possible to set a layer as source and receiver at the same time."))
            self.buttonBox.setEnabled( True )
            return
            
        if self.obstacles_layer_checkBox.isChecked() and self.obstacles_layer_comboBox.currentText() == "":
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("Please specify the obstacles polygon vector layer."))
            self.buttonBox.setEnabled( True )
            return 0

        if self.rays_layer_checkBox.isChecked() and self.rays_layer_lineEdit.text() == "":
            QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("Please specify output shapefile name for the sound rays."))          
            self.buttonBox.setEnabled( True )
            return
            
        else:
            
            source_layer = QgsMapLayerRegistry.instance().mapLayersByName(self.source_layer_comboBox.currentText())[0]
            if self.power_comboBox.currentText() == self.tr('choose field'):
                power_field = 'none'
            else:
                power_field = self.power_comboBox.currentText()
            
            receiver_layer = QgsMapLayerRegistry.instance().mapLayersByName(self.receiver_layer_comboBox.currentText())[0]
            
            # CRS control (each layer must have the same CRS)            
            if source_layer.crs().authid() != receiver_layer.crs().authid():
                QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr("The layers don't have the same CRS (Coordinate Reference System). Please use layers with same CRS."))          
                self.buttonBox.setEnabled( True )
                return

            
            research_ray = int(self.research_ray_comboBox.currentText())
            if self.obstacles_layer_checkBox.isChecked():
                obstacles_layer = QgsMapLayerRegistry.instance().mapLayersByName(self.obstacles_layer_comboBox.currentText())[0]
            else:
                obstacles_layer = ""            
            
            if self.rays_layer_checkBox.isChecked():
                rays_layer_path = self.rays_layer_lineEdit.text()
            else:
                rays_layer_path = ""
            
            # writes the settings log file
            self.log_start()
            
            log_settings.write(self.tr("Source layer:") + "\n" + source_layer.source() + "\n\n")
            log_settings.write(self.tr("Receiver layer:") + "\n" + receiver_layer.source() + "\n\n")
            log_settings.write(self.tr("Research ray:") + "\n" + str(research_ray) + "\n\n")
            if obstacles_layer == "":
                log_settings.write(self.tr("Obstacles layer:") + "\n" + self.tr("None") + "\n\n")
            else:
                log_settings.write(self.tr("Obstacles layer:") + "\n" + obstacles_layer.source() + "\n\n")            
            if rays_layer_path == "":
                log_settings.write(self.tr("Rays layer:") + "\n" + self.tr("None") + "\n\n")
            else:
                log_settings.write(self.tr("Rays layer:") + "\n" + str(rays_layer_path) + "\n\n")    
                
            self.time_start = datetime.now()
            
            # PointSourceCalculation
            try:
                self.run(source_layer,power_field,receiver_layer,research_ray,obstacles_layer,rays_layer_path)
                run = 1
            except:
                error= traceback.format_exc()
                log_errors.write(error)
                run = 0
                
            self.time_end = datetime.now()

            if run == 1:
                log_errors.write(self.tr("No errors.") + "\n\n") 
                result_string = self.tr("Levels from point source calculated with success.") + "\n\n" +\
                                 self.tr("View and rename the settings file to keep it:") + "\n" +\
                                 str(log_settings_path_name) + "\n\n" + str(self.duration())
                QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), result_string)
                self.iface.messageBar().pushMessage(self.tr("opeNoise - Point Source Calculation"), self.tr("Process complete"))
            else:
                result_string = self.tr("Sorry, process not complete.") + "\n\n" +\
                                self.tr("View the log file to understand the problem:") + "\n" +\
                                str(log_errors_path_name) + "\n\n" + str(self.duration())
                QMessageBox.information(self, self.tr("opeNoise - Point Source Calculation"), self.tr(result_string))
                self.iface.messageBar().pushMessage(self.tr("opeNoise - Point Source Calculation"), self.tr("Process not complete"))

            
            log_settings.write("\n\n=======================================================\n")
            log_settings.write(result_string)
            
            self.log_end()
        
                
        
        self.progressBar.setValue(0)
        self.buttonBox.setEnabled( True )

        self.iface.mainWindow().statusBar().clearMessage()
        self.iface.mapCanvas().refresh() 
        self.close()
        
    def duration(self):
        duration = self.time_end - self.time_start
        duration_h = duration.seconds/3600
        duration_m = (duration.seconds - duration_h*3600)/60
        duration_s = duration.seconds - duration_m*60 - duration_h*3600
        duration_string = self.tr("Starting time: ") + self.time_start.strftime("%a %d/%b/%Y %H:%M:%S.%f") + "\n" +\
                          self.tr("Ending time: ") + self.time_end.strftime("%a %d/%b/%Y %H:%M:%S.%f") + "\n"+\
                          self.tr("Execution time: ") + str(duration_h) + self.tr(" hours, ") + str(duration_m) + \
                          self.tr(" minutes, ") + str(duration_s) + "." + str(duration.microseconds) + self.tr(" seconds.")
        return duration_string

    # computes distance (input two QgsPoints, return a float)    
    def compute_distance(self,QgsPoint1,QgsPoint2):
        return sqrt((QgsPoint1.x()-QgsPoint2.x())**2+(QgsPoint1.y()-QgsPoint2.y())**2)
    
    def noise_levels_computation(self, source_layer,power_field,receiver_layer,research_ray,obstacles_layer,obstacles_spIndex,obstacles_feat_all_dict,emission_points_spIndex,emission_points_feat_all_dict,rays_layer_path,rays_writer,level_field_index):
          
        self.progressBar.setValue(0)
        
        ray_id = 0
        # calculates levels for each receiver point
        receiver_points_feat_all = receiver_layer.dataProvider().getFeatures()
        receiver_points_feat_all_number = 0
        
        receiver_point_field_level =  {}
        
        for receiver_points_feat in receiver_points_feat_all:

            receiver_points_feat_all_number = receiver_points_feat_all_number + 1
            bar = receiver_points_feat_all_number/float(receiver_points_feat_total)*100
            self.progressBar.setValue(bar)

            # initializes the receiver point field level
            field_level = {}
            
            # initializes the receiver point lin level
            receiver_point_lin_level = 0
       
            
            # researches the emission points in a rectangle created by the research_ray
            # creates the search rectangle
            rect = QgsRectangle()
            rect.setXMinimum( receiver_points_feat.geometry().asPoint().x() - research_ray )
            rect.setXMaximum( receiver_points_feat.geometry().asPoint().x() + research_ray )
            rect.setYMinimum( receiver_points_feat.geometry().asPoint().y() - research_ray )
            rect.setYMaximum( receiver_points_feat.geometry().asPoint().y() + research_ray )
            
            emission_points_request = emission_points_spIndex.intersects(rect)
            #log_errors.write(str(roads_powers.keys())+'\n')
            for emission_points_id in emission_points_request:
                
                emission_points_feat = emission_points_feat_all_dict[emission_points_id] 
                
                
                if emission_points_feat.attributes()[source_layer.fieldNameIndex(power_field)] != None:
                    power = emission_points_feat.attributes()[source_layer.fieldNameIndex(power_field)]
                else:
                    power = 0

                
                ray_to_test_length = self.compute_distance(receiver_points_feat.geometry().asPoint(),emission_points_feat.geometry().asPoint())

                if ray_to_test_length <= research_ray:

                    ray_to_test = QgsGeometry.fromPolyline( [ receiver_points_feat.geometry().asPoint() , emission_points_feat.geometry().asPoint() ] ) 

                    intersect = 0
                
                    if obstacles_layer <> "":
                        obstacles_request = obstacles_spIndex.intersects(ray_to_test.boundingBox())
                        for obstacles_id in obstacles_request:
                            if obstacles_feat_all_dict[obstacles_id].geometry().intersects(ray_to_test) == 1:
                                intersect = 1
                                break
                    
                    # if the ray is free from intersections it's added in the ray layer with the the sound level computation
                    if intersect == 0:

                        level = 0
                        level_lin = 0
                        
                        if power > 0:
                            level = power - 11 - 20*log10(ray_to_test_length)
                            level_lin = 10**(level/float(10))
                        else:
                            level = 0
                            level_lin = 0
                        receiver_point_lin_level = receiver_point_lin_level + level_lin


                        if rays_layer_path <> "":
                            ray = QgsFeature()
                            ray.setGeometry(ray_to_test)
                            attributes = [ray_id, receiver_points_feat.id(), emission_points_feat.id(), ray_to_test_length]
                            attributes.append(power)
                            attributes.append(level)
                            attributes.append(level_lin)
      
                            ray.setAttributes(attributes)
                            rays_writer.addFeature(ray)

                        ray_id = ray_id + 1
            
            
            
            if receiver_point_lin_level > 0:
                field_level[level_field_index] = 10*log10(receiver_point_lin_level)                
            else:
                field_level[level_field_index] = -1

            #if receiver_point_lin_level['gen'] > 0 or receiver_point_lin_level['nig'] > 0 or receiver_point_lin_level['day'] > 0 or receiver_point_lin_level['eve'] > 0:
            #    receiver_point_field_level[receiver_points_feat.id()] = field_level
            receiver_point_field_level[receiver_points_feat.id()] = field_level    

        if rays_layer_path <> "":
            del rays_writer

            
        return receiver_point_field_level            
        
        
    def run(self, source_layer,power_field,receiver_layer,research_ray,obstacles_layer,rays_layer_path):

        
        # gets vector layers, features amd creates SpatialIndex if need
        
        #source layer
        # gets features amd creates SpatialIndex for emission points
        emission_points_feat_all_dict = {}
        emission_points_feat_all = source_layer.dataProvider().getFeatures()
        emission_points_spIndex = QgsSpatialIndex()            
        for emission_points_feat in emission_points_feat_all:
            emission_points_spIndex.insertFeature(emission_points_feat)
            emission_points_feat_all_dict[emission_points_feat.id()] = emission_points_feat               
        
        # receiver layer        
        global receiver_points_feat_total 
        receiver_points_feat_total = receiver_layer.dataProvider().featureCount()
        receiver_points_feat_all = receiver_layer.dataProvider().getFeatures()
        receiver_points_spIndex = QgsSpatialIndex()
        receiver_points_feat_all_dict = {}
        for receiver_points_feat in receiver_points_feat_all:
            receiver_points_spIndex.insertFeature(receiver_points_feat)
            receiver_points_feat_all_dict[receiver_points_feat.id()] = receiver_points_feat       

        # gets fields from recever point layer and initializes the final receiver_point_field_level to populate the receiver points layer attribute table
        fields_number = int(receiver_layer.dataProvider().fields().count())
        level_field_index = fields_number
        fields_number = fields_number + 1
        
        
        # obstacles
        if obstacles_layer <> "":
            obstacles_feat_all = obstacles_layer.dataProvider().getFeatures()
            obstacles_spIndex = QgsSpatialIndex()
            obstacles_feat_all_dict = {}
            for obstacles_feat in obstacles_feat_all:
                obstacles_spIndex.insertFeature(obstacles_feat)
                obstacles_feat_all_dict[obstacles_feat.id()] = obstacles_feat
        else:
            obstacles_spIndex = ""
            obstacles_feat_all_dict = ""
            
         
        # defines rays layer
        if rays_layer_path <> "":
            rays_fields = [QgsField("id_ray", QVariant.Int), QgsField("id_rec", QVariant.Int),
                           QgsField("id_source", QVariant.Int), QgsField("distance", QVariant.Double,len=10,prec=2)]
            rays_fields.append(QgsField("power", QVariant.Double,len=5,prec=1))
            rays_fields.append(QgsField("level", QVariant.Double,len=5,prec=1))
            rays_fields.append(QgsField("level_lin", QVariant.Double,len=10,prec=1))               
                 
            rays_writer = VectorWriter(rays_layer_path, None, rays_fields, 2, receiver_layer.crs())
        else:
            rays_writer = ""        
            
            
        #calculation
        receiver_point_field_level = self.noise_levels_computation(source_layer,power_field,receiver_layer,research_ray,obstacles_layer,obstacles_spIndex,obstacles_feat_all_dict,emission_points_spIndex,emission_points_feat_all_dict,rays_layer_path,rays_writer,level_field_index)

        # puts the sound level in the receivers points attribute table
        level_fields = []
        level_fields.append(QgsField('level', QVariant.Double,len=5,prec=1))
                
        receiver_layer.dataProvider().addAttributes( level_fields )
        receiver_layer.updateFields()
        receiver_layer.dataProvider().changeAttributeValues(receiver_point_field_level)  
        
        # render with noise colours          
        level_fields_new = list(receiver_layer.dataProvider().fields())
        
        if len(level_fields_new) > 0:
            render(receiver_layer,level_fields_new[len(level_fields_new)-1].name())
        
        if rays_layer_path <> "":
            del rays_writer
            rays_layer_name = os.path.splitext(os.path.basename(rays_layer_path))[0]

            rays_layer = QgsVectorLayer(rays_layer_path, unicode(rays_layer_name), "ogr")

            QgsMapLayerRegistry.instance().addMapLayers([rays_layer])    
            
            # render with noise colours          
            rays_layer_list = list(rays_layer.dataProvider().fields())
            render(rays_layer,rays_layer_list[len(rays_layer_list)-2].name())
            
            
        

        
        
    
